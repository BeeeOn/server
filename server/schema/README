= Database schema and queries =

The database schema is described by XML file and by applying XSL transformations
the target SQL code is generated for a selected database engine.

All SQL queries are specified in another XML file. It includes test definitions
as well. By applying XSL transformations, query file for application, testing
code and expected results are generated.


== Requirements ==

* xsltproc - tool provided usually by package libxslt
* graphviz - tool to visualize graphs (optional)


== Automatic generation of runtime files ==

All required files are generated automatically by cmake infrastructure. Simply run
cmake from the top-level directory of the project. It automatically generates the
sqlite and postgresql schema files and an appropriate INI files with SQL queries.


== Manual generation of SQL schema ==

Prepare SQL commands for SQLite and PostgreSQL engines. A visualization of the schema
can be also generated by utilizing program dot. Generate appropriate SQL schema scripts
by following those steps:

  $ xsltproc ../tools/xsl/schema.sqlite.xsl home8.xml
  $ xsltproc ../tools/xsl/schema.postgre.xsl home8.xml
  $ ls
  home8.xml  home8-query.xml  home8-sqlite.sql  home8-postgre.sql  README


== Manual generation of queries ==

The application requries an external file with queries to work properly. The queries
are generated by XSL transformations:

  $ xsltproc --stringparam engine sqlite ../tools/xsl/query.export.xsl home8-query.xml
  $ ls
  home8.xml  home8-query.xml  home8-sqlite-queries.ini  README

  $ xsltproc --stringparam engine postgre ../tools/xsl/query.export.xsl home8-query.xml
  $ ls
  home8.xml  home8-query.xml  home8-postgre-queries.ini  README


== Manual generation of testing SQL scripts ==

The queries can optionally contain unit tests. The unit tests consist of some SQL
statements that modifies database temporarily. The output of the test is a CSV file
with results retreived by checking SELECT statements. If some database engine does
not support CSV export, an additional conversion tools might be required or provided.
Resulted CSV file can be compared to an expected output generated by the XSLT.
Steps:

  $ xsltproc --stringparam engine sqlite ../tools/xsl/query.test.xsl home8-query.xml
  $ ls
  home8.xml  home8-query.xml  home8-sqlite-test.sql  home8-sqlite-expect.csv  README

  $ xsltproc --stringparam engine postgre ../tools/xsl/query.test.xsl home8-query.xml
  $ ls
  home8.xml  home8-query.xml  home8-postgre-test.sql  home8-postgre-expect.csv  README


== Execute sqlite tests ==

First, generate testing files and SQL schema for the sqlite engine as described earlier.

  $ ls
  home8.xml  home8-query.xml  home8-sqlite.sql  home8-sqlite-test.sql  README
  home8-sqlite-expect.csv
  $ cat home8-sqlite.sql home8-sqlite-test.sql | sqlite3
  $ ls
  home8.xml  home8-query.xml  home8-sqlite.sql  home8-sqlite-test.sql  README
  home8-sqlite-expect.csv  home8-sqlite-test.csv
  $ diff -uw home8-sqlite-expect.csv home8-sqlite-test.csv

Note that different sqlite3 versions outputs different end-of-line marks. This is
difficult to detect in our test generators. So expect simple LF end-of-line and
ignore the whitespace differences by diff.


== Execute postgre tests ==

First, generate testing files and SQL schema for postgre engine as described earlier.

  $ ls
  home8.xml  home8-query.xml  home8-postgre.sql  home8-postgre-test.sql  README
  home8-postgre-expect.csv

Configure access from your system account to a selected empty database in your
PostgreSQL database engine. Example:

  $ whoami
  joe
  $ su - postgres
  $ psql
  > CREATE USER joe;
  > CREATE DATABASE testing OWNER joe;
  > \q
  $ exit

Execute tests on the selected database:

  $ export DBNAME=testing
  $ cat home8-postgre.sql home8-postgre-test.sql | psql -q -t ${DBNAME}
  $ ls
  home8.xml  home8-query.xml  home8-postgre.sql  home8-postgre-test.sql  README
  home8-postgre-expect.csv  home8-postgre-test.csv

Check test results:

  $ diff -u home8-postgre-expect.csv home8-postgre-test.csv
