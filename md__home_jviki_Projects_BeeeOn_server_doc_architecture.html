<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BeeeOn Server: Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="BeeeOn.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BeeeOn Server
   &#160;<span id="projectnumber">v2018.11.1</span>
   </div>
   <div id="projectbrief">Platform to interconnect the IoT world</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>BeeeOn Server is based on the 3-layer architecture. It is divided as:</p>
<ul>
<li>Frontend (API) - REST-UI, XML-UI, GWS</li>
<li>Services - application logic on model objects</li>
<li>DAO and misc - access to database and external services</li>
</ul>
<div class="image">
<img src="top-level.png" alt="top-level.png"/>
<div class="caption">
Top-level overview of BeeeOn Server</div></div>
 <h2>Gateway Server (GWS)</h2>
<p>Gateway Server maintains a list of connected BeeeOn Gateways. It receives measured sensoric data and manages processing of commands and their results. Each gateway is verified when connected which is usually based on TLS client certificate verification. To protect the Gateway Server against DoS-like behaviours (too many messages from a gateway), each gateway's traffic can be rate limited.</p>
<div class="image">
<img src="gws.png" alt="gws.png"/>
<div class="caption">
Overview of Gateway Server</div></div>
<p> Gateway Server manages a WebSocket server that listens for incoming upgradable HTTP connections. When a WebSocket connection is established and the remote gateway is verified, the connection is registered with the <code>GatewayCommunicator</code> that takes care of the rest of the communication.</p>
<p><code>GatewayCommunicator</code> handles incoming messages from gateways via <code>Poco::Net::SocketReactor</code> and (except of low-level WebSocket frames) passes them to the configured <code>GWMessageHandler</code> instance. Everytime a gateway is connected, disconnected or re-connected (this means 2 consecutive connections from the same gateway without disconnection in between), an event is generated and propagated into the configured <code>GatewayWatcher</code> instances.</p>
<p><code>GatewayPeerVerifierFactory</code> can create a kind of <code>GatewayPeerVerifier</code> instances that knows how to verify a gateway. The <code>X509GatewayPeerVerifier</code> implementation (and its factory) verifies TLS client certificate of the given <code>Poco::Net::StreamSocket</code> and checks whether the TLS certificate contains the same <em>gateway ID</em> in its <em>common name</em> as presented in the received registration message from the gateway. To relax the rules (especially for testing or debugging purposes), there is a class named <code>RelaxedGatewayPeerVerifier</code> (and factory) that wraps any other implementation while avoiding failing of the true verification process. Using it is <b>not intended for production use</b>.</p>
<p>When a gateway is too agressive in sending messages (due to a bug or a malicious behaviour), each gateway connection is associated with an instance of <code>GatewayRateLimiter</code>. Such instance is used to deny reception of messages under certain conditions. There are at least two implementations (with factories): <code>NoGatewayRateLimiter</code> that permits all messages and <code>SlidingWindowRateLimiter</code> that limits the incoming message rate per minute or/and per hour.</p>
<h2>REST-UI</h2>
<p>The REST-UI is a HTTP(s) server that handles REST requests. It is protected by an authentication layer and configurable through INI configuration file usually named <code>restui-api.ini</code>.</p>
<div class="image">
<img src="rest-ui.png" alt="rest-ui.png"/>
<div class="caption">
Overview of REST-UI</div></div>
 <h3>Processing requests</h3>
<p>All incoming HTTP requests are processed by <code>PocoRestServer</code> that wraps the <code>Poco::Net::HTTPServer</code> instance:</p>
<ol type="1">
<li>The server preprocesses HTTP headers (and body) via configurable component <code>HTTPFilterChain</code>. E.g. CORS is implemented by a separate <code>HTTPFilter</code> in this chain.</li>
<li>Because nearly all REST endpoints require authentication, it is necessary to check the user session as soon as possible to determine whether the request is valid. For this purpose, the <code>PocoRestServer</code> uses an instance of <code>SessionVerfier</code>.</li>
<li>Valid requests are than routed via a <code>RestRouter</code> into the target handling component. Mapping between URI and handlers is described in the <code>restui-api.ini</code> file. The mappings are sometimes called <em>endpoints</em>. Each mapping has associated a set of properties (described later).</li>
<li><code>PocoRestServer</code> manages locale and languages for user. It determines the user's locale from 2 sources: <code>Accept-Language</code> header or locale stored for each user in the database. The user locale is preferred. It is possible to force using of the Accept-Language header via a custom header <code>X-Prefer-Request-Language: yes</code>.</li>
<li>The <code>PocoRestServer</code> internally uses 2 special endpoints: <code>builtin.noroute</code> and <code>builtin.unauthorized</code> which can be associated to a special handler. This is done during the <code>RestRouter</code> initialization by injecting a particular handler implementing the appropriately named <code>builtin</code> actions.</li>
</ol>
<h3>Configuration of endpoints</h3>
<p>Each endpoint is defined by a mapping between its URI and handler. There can be multiple URIs for a single handler. Each handler is identified by ID consisting of <em>group name</em> and <em>call name</em>. In the file <code>restui-api.ini</code>, the mappings are described as:</p>
<div class="fragment"><div class="line">api.call.&lt;GROUP&gt;.&lt;CALL&gt;.uri = &lt;URI&gt;</div></div><!-- fragment --><p>Example of the authentication endpoints:</p>
<div class="fragment"><div class="line">api.call.auth.list.uri = /auth</div><div class="line">api.call.auth.list.method = GET</div><div class="line">api.call.auth.list.session.required = no</div><div class="line">api.call.auth.list.input.maxsize = 0</div><div class="line">api.call.auth.list.caching = 360</div><div class="line"></div><div class="line">api.call.auth.list.uri = /auth</div><div class="line">api.call.auth.list.method = POST</div><div class="line">api.call.auth.list.session.required = no</div><div class="line">api.call.auth.list.input.maxsize = 1024</div><div class="line">api.call.auth.list.caching = no</div></div><!-- fragment --><p>You can see that <code>GET /auth</code> would list authentication methods while <code>POST /auth</code> is used to perform login. Both endpoints has other configuration settings instructing the PocoRestServer to behave accordingly.</p>
<p>The property <code>api.call.&lt;FULL_NAME&gt;.session.required</code> determines whether the endpoint can be accessed without a session or whether a session is required. Is a session is required and missing, the request is redirected internally to the special endpoint <code>builtin.unauthorized</code>.</p>
<p>It is possible to limit size of each request's body. This is usually the case of POST and PUT methods. Too big body is automatically refused with HTTP code 400. The check for input size can be disabled by setting the <code>api.call.&lt;FULL_NAME&gt;.input.maxsize</code> to a negative value (-1).</p>
<p>Some requests might be cached on client or some caching proxy layer. Such endpoints can be configured via setting <code>api.call.&lt;FULL_NAME&gt;.caching</code> to send advertise HTTP headers Cache-Control and Expires. The behaviour of this features works as follows:</p>
<ul>
<li>for builtin endpoints <code>Cache-Control: public, no-cache</code> is always inserted</li>
<li>when value of <code>caching</code> is <em>off</em> or <em>ignore</em>, no caching header is inserted for that endpoint</li>
<li>when value of <code>caching</code> is <em>never</em> or <em>no</em>, the <code>Cache-Control: public, no-cache</code> is inserted</li>
<li>when <code>caching</code> is a number (in seconds), 2 HTTP headers are inserted: <code>Cache-Control: max-age=&lt;value&gt;, must-revalidate</code> and the second <code>Expires: &lt;now + value&gt;</code></li>
</ul>
<h2>Internal interaction with GWS</h2>
<p>Communication between the BeeeOn Server core and GWS is necessary to allow users to configure their gateways. Currently, the core and GWS are separated by the GatewayRPC interface which performs asynchronous calls.</p>
<div class="image">
<img src="gws-dependencies.png" alt="gws-dependencies.png"/>
<div class="caption">
Components used for communication with GWS</div></div>
<p> The implementation <code>AsyncGatewayRPC</code> directly accesses the <code>GatewayCommunicator</code> to issue command requests to remote gateways. The command results are communicated back via the <code>GWMessageHandler</code>. All outstanding commands are temporarily stored in <code>GWResponseExpectedQueue</code> waiting for state update, finish, fail or timeout.</p>
<p>Design of <code>GatewayRPC</code> is a subject of rework because the components are too tightly coupled together. Releasing the relations would allow to run Gateway Server as a standalone application. This might be useful e.g. to implement load balancing.</p>
<h2>Authentication</h2>
<p>Authentication of users into the application is implemented by an instance of <code>AuthService</code> interface. The default implementation <code>AuthServiceImpl</code> uses a list of registered <code>AuthProvider</code> instances. BeeeOn Server is intentionally not designed to implement authorization of users directly, instead all authorization is usually implemented via OAuth. Users are thus registered automatically when a configured remote authorization service allows to.</p>
<div class="image">
<img src="auth-service.png" alt="auth-service.png"/>
<div class="caption">
Overview of AuthService</div></div>
<p> It is possible to list all available login methods (registered <code>AuthProvider</code> instances). The user can select which login method to use and perform the associated steps. There are currently 3 <code>AuthProvider</code> implementations:</p>
<ul>
<li><code>PermitAuthProvider</code> - intended for <b>testing purposes</b> as it can login <b>ANY</b> existing user without verification</li>
<li><code>ApiKeyAuthProvider</code> - reads a properties file (usually <code>apikeys.properties</code>) that contains mappings between API keys and users</li>
<li><code>OAuth2AuthProvider</code> - uses an external OAuth 2 service that authorizes users in their own way</li>
</ul>
<p>The OAuth2AuthProvider uses an instance of <code>OAuth2CodeExchanger</code> and <code>OAuth2UserFetcher</code> to process the authorization token from a user. The <code>OAuth2CodeExchanger</code> verifies the token with the remote service and <code>OAuth2UserFetcher</code> fetches information about the user. The implementations for Google and Facebook OAuth services are provided. Other services might require a custom implementation of one of those interfaces. Support of certain services can be added easily via <code>GenericCodeExchanger</code> implements a generic and configurable way to exchange the tokens. If the service provides user information in the OpenID format (JWT with some standardized fields), the user data can be decoded via <code>OpenIDUserDecoder</code>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
