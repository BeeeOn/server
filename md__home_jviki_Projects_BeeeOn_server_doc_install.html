<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BeeeOn Server: Installation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="BeeeOn.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BeeeOn Server
   &#160;<span id="projectnumber">v2018.07.1</span>
   </div>
   <div id="projectbrief">Platform to interconnect the IoT world</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Installation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The recommended way to install the BeeeOn Server is to use an RPM package. The RPM package installs the BeeeOn Server software with a configuration that is to be amended before running. The systemd service is included.</p>
<h2>Before first run</h2>
<p>Before the BeeeOn Server can be started, several configuration entries should be set and the database must be initialized. The configuration can be usually found at <code>/etc/beeeon/server</code>. The main configuration file is called <code>server-startup.ini</code>. The directory <code>config.d</code> contains files that are also applied and can be used to override the main configuration entries. It is recommanded to customize the configuration settings by creating new INI files there.</p>
<p>At least the following entries must be configured:</p>
<ul>
<li>secure.device_properties.passphrase</li>
</ul>
<p>For details, see the following sections.</p>
<h3>XML-UI Server</h3>
<p>The group <code>xmlui.ssl</code> configures using of SSL layer for the XML-UI Server. The available entries are:</p>
<ul>
<li>xmlui.ssl.enable - enable SSL layer for the XML-UI Server</li>
<li>xmlui.ssl.key - file path to private key of the XML-UI Server</li>
<li>xmlui.ssl.certificate - file path to public key of the XML-UI Server signed by a CA</li>
<li>xmlui.ssl.authority - file path to CA certificate</li>
<li>xmlui.ssl.verifyMode - SSL verify mode (none, relaxed, strict, once)</li>
</ul>
<h3>REST-UI Server</h3>
<p>The group <code>restui.ssl</code> configures using of SSL layer for the REST-UI Server. The available entries are:</p>
<ul>
<li>restui.ssl.enable - enable SSL layer for the REST-UI Server</li>
<li>restui.ssl.key - file path to private key of the REST-UI Server</li>
<li>restui.ssl.certificate - file path to public key of the REST-UI Server signed by a CA</li>
<li>restui.ssl.authority - file path to CA certificate</li>
<li>restui.ssl.verifyMode - SSL verify mode (none, relaxed, strict, once)</li>
</ul>
<h3>Gateway Server (GWS)</h3>
<p>The group <code>gws.ws.ssl</code> configures using of SSL layer for the GWS. The available entries are:</p>
<ul>
<li>gws.ws.ssl.enable - enable SSL layer for the GWS websockets</li>
<li>gws.ws.ssl.key - file path to private key of the GWS</li>
<li>gws.ws.ssl.certificate - file path to public key of the GWS signed by a CA</li>
<li>gws.ws.ssl.authority - file path to CA certificate</li>
<li>gws.ws.ssl.verifyMode - SSL verify mode (none, relaxed, strict, once)</li>
</ul>
<p>Gateways are verified against server by their SSL/TLS certificate. The verification is influenced either by the SSL settings listed above and by the configuration entry</p>
<ul>
<li>gws.peer.verifier - gateway verification strategy</li>
</ul>
<p>There are currently the following verification strategies:</p>
<ul>
<li>relaxed - all gateways are accepted (for debugging and testing)</li>
<li>strict - only gateways connected via SSL/TLS connection with a valid certificate signed by a trusted CA and with a valid gateway ID is accepted</li>
</ul>
<p>The recommended configuration that is considered safe is:</p>
<ul>
<li>gws.ws.ssl.verifyMode = strict</li>
<li>gws.peer.verifier = strict</li>
</ul>
<h3>Device Properties</h3>
<p>Certain device properties stored in the main database are encrypted at the application level. For this purpose, a passphrase must be configured to work properly. The passphrase should be long enough and generated in a secure random way (e.g. by pwgen). The passphrase must not change, once it is used (unless the database contents are re-encrypted).</p>
<p>The available entries are:</p>
<ul>
<li>secure.device_properties.algorithm - name of algorithm to use (aes256)</li>
<li>secure.device_properties.passphrase - secure random passphrase</li>
</ul>
<p>The passphrase must be set. A possible generation method:</p>
<div class="fragment"><div class="line">$ pwgen -s -N 1 64</div></div><!-- fragment --><h3>Database</h3>
<p>The only supported database at the moment is the PostgreSQL via ODBC. There is no need to configure anything unless some non-standard settings are used. The available entries are:</p>
<ul>
<li>database.host - host (should be usually localhost)</li>
<li>database.port - port where the PostgreSQL instance is listening</li>
<li>database.user - user name when connecting to database</li>
<li>database.name - name of database to use (beeeon)</li>
</ul>
<h3>Database initialization</h3>
<p>The database must be initialized before the first run. For this purpose, there is an initialization script a set of deploy scripts versioned by the Sqitch management system. The Sqitch is currently a mandatory tool for initialization. All the necessary scripts can be (usually) found in <code>/usr/share/beeeon/db</code>.</p>
<p>The initialization is done in few steps:</p>
<ol type="1">
<li>Initialize database and create user role <code>beeeon_user</code>:</li>
</ol>
<div class="fragment"><div class="line">$ cd /usr/share/beeeon/db/scripts</div><div class="line">$ sudo -u postgres psql -f beeeon_pg_init.sql</div></div><!-- fragment --><ol type="1">
<li>Deploy the database schema by Sqitch:</li>
</ol>
<div class="fragment"><div class="line">$ SQITCH=$(which sqitch)</div><div class="line">$ cd /usr/share/beeeon/db</div><div class="line">$ sudo -u beeeon_admin ${SQITCH} deploy beeeon</div></div><!-- fragment --><ol type="1">
<li>Optionally, it is now possible (the database is empty) to execute unit-tests (requires pgtap):</li>
</ol>
<div class="fragment"><div class="line">$ cd /usr/share/beeeon/db/test</div><div class="line">$ sudo -u beeeon_admin pg_prove t*.sql</div></div><!-- fragment --><p>If all the steps has successfully passed, the database is initialized.</p>
<h3>JWT Session Manager</h3>
<p>When the JWT Session Manager is enabled, it must be configured accordingly. The JWT requires to setup the cryptography. The available entries are:</p>
<ul>
<li>session.manager - name of manager to use (system, jwt)</li>
<li>session.jwt.secret - passphrase for signing JWTs</li>
<li>session.jwt.algorithm - algorithm for signing of JWTs (HS256, HS512, ...)</li>
<li>session.jwt.audience - names of other system that should be accepting our JWTs</li>
</ul>
<h3>Client authentication</h3>
<p>The OAuth 2.0 login can be setup up in different configurations. Usually, the particular providers need to be configured differently for various clients:</p>
<ul>
<li>web application</li>
<li>Android application</li>
<li>iOS application</li>
<li>etc.</li>
</ul>
<p>For this purpose, the authentication settings are divided into sections:</p>
<ul>
<li>web-app</li>
<li>android</li>
<li>any other...</li>
</ul>
<p>There are, however, settings which can be shared among all those instances. This is usually the SSL configuration.</p>
<h4>Google OAuth 2.0</h4>
<p>To enable login via the Google OAuth 2.0, it is necessary to configure the Google ID and secret and to configure the SSL.</p>
<p>The SSL configuration is shared among all Google Auth providers:</p>
<ul>
<li>google.ssl.verifyMode - SSL verify mode</li>
<li>google.ssl.authority - path to CA to verify connection to Google</li>
</ul>
<p>For web applications, there is the section web-app in the configuration file:</p>
<ul>
<li>web-app.google.enable - enable using of the Google OAuth 2.0</li>
<li>web-app.google.clientId - client ID (obtain from Google)</li>
<li>web-app.google.clientSecret - secret passphrase (obtain from Google)</li>
</ul>
<p>For Android applications, there is the section android in the configuration file:</p>
<ul>
<li>android.google.enable - enable using of the Google OAuth 2.0</li>
<li>android.google.clientId - client ID (obtain from Google)</li>
<li>android.google.clientSecret - secret passphrase (obtain from Google)</li>
</ul>
<h4>Facebook OAuth 2.0</h4>
<p>To enable login via the Facebook OAuth 2.0, it is necessary to configure the Facebook ID and secret and to configure the SSL. Similar to the Google OAuth 2.0, more different configuration are possible while the SSL configuration is shared:</p>
<ul>
<li>facebook.ssl.verifyMode - SSL verify mode</li>
<li>facebook.ssl.authority - path to CA to verify connection to Facebook</li>
</ul>
<p>For web applications:</p>
<ul>
<li>web-app.facebook.enable - enable using of the Facebook OAuth 2.0</li>
<li>web-app.facebook.clientId - client ID (obtain from Facebook)</li>
<li>web-app.facebook.clientSecret - secret passphrase (obtain from Facebook)</li>
</ul>
<h2>Logging</h2>
<p>The BeeeOn Server utilizes the Poco Logging Framework for logging purposes. The initial logging configuration is divided into 2 files:</p>
<ul>
<li>server-startup.ini - general configuration</li>
<li>config.d/logging.ini - configuration of particular loggers</li>
</ul>
<p>The configuration is prepared for 3 cases:</p>
<ul>
<li>logging to the console (useful also for journald)</li>
<li>logging via Poco::FileChannel that ensures rotations on its own (this is not a bullet-proof implementation but it just works)</li>
<li>logging via standard syslog API</li>
</ul>
<p>The initial configuration enables logging to console (with colors) and via Poco::FileChannel into the /var/log/beeeon/server.log with rotations. To change this, please tweak the configuration options:</p>
<ul>
<li>logging.channels.split.channels - list of channels to log into</li>
<li>logging.root.level - logging level of the root logger</li>
<li>for others, see <a href="https://pocoproject.org/docs/Poco.FileChannel.html">FileChannel</a>, <a href="https://pocoproject.org/docs/Poco.SyslogChannel.html">SyslogChannel</a>, <a href="https://pocoproject.org/docs/Poco.ConsoleChannel.html">ConsoleChannel</a> and <a href="https://pocoproject.org/docs/Poco.PatternFormatter.html">PatternFormatter</a> docs. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
